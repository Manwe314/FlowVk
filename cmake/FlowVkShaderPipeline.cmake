include_guard(GLOBAL)

# FlowVk root (repo) relative to this file
set(_FLOWVK_ROOT "${CMAKE_CURRENT_LIST_DIR}/..")

# -----------------------------------------------------------------------------
# Internal: ensure FlowVk_ShaderPP tool target exists.
# -----------------------------------------------------------------------------
function(_flowvk_ensure_shaderpp_tool)
  if(TARGET FlowVk_ShaderPP)
    return()
  endif()

  set(_pp_src "${_FLOWVK_ROOT}/src/FlowVk_ShaderPP.cpp")
  if(NOT EXISTS "${_pp_src}")
    message(FATAL_ERROR
      "FlowVk: FlowVk_ShaderPP tool source not found at:\n"
      "  ${_pp_src}\n"
      "Expected file: src/FlowVk_ShaderPP.cpp"
    )
  endif()

  add_executable(FlowVk_ShaderPP "${_pp_src}")
  target_compile_features(FlowVk_ShaderPP PRIVATE cxx_std_23)
  target_include_directories(FlowVk_ShaderPP PRIVATE "${_FLOWVK_ROOT}/include")

  set_target_properties(FlowVk_ShaderPP PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin"
  )
endfunction()

# -----------------------------------------------------------------------------
# Internal: require Vulkan glslc
# -----------------------------------------------------------------------------
function(_flowvk_require_glslc)
  find_package(Vulkan REQUIRED COMPONENTS glslc)
  if(NOT Vulkan_GLSLC_EXECUTABLE)
    message(FATAL_ERROR
      "FlowVk: glslc was not found via Vulkan SDK.\n"
      "Make sure the Vulkan SDK is installed and your environment is set up (e.g., VULKAN_SDK),\n"
      "then re-run CMake configure."
    )
  endif()
endfunction()

# -----------------------------------------------------------------------------
# Internal: enforce unique kernel stems (filename without extension).
# User rule: stem before .comp must be unique in the target.
# -----------------------------------------------------------------------------
function(_flowvk_validate_unique_stems SHADERS)
  set(_seen "")
  foreach(SHADER IN LISTS SHADERS)
    get_filename_component(_stem "${SHADER}" NAME_WE) # "multiply" from "multiply.comp"
    list(FIND _seen "${_stem}" _idx)
    if(NOT _idx EQUAL -1)
      message(FATAL_ERROR
        "FlowVk: Duplicate kernel name '${_stem}'.\n"
        "Kernel names are derived from shader filename stems and must be unique.\n"
        "Conflicting shader: ${SHADER}"
      )
    endif()
    list(APPEND _seen "${_stem}")
  endforeach()
endfunction()

# -----------------------------------------------------------------------------
# Internal: add commands for one shader.
# Outputs:
#   <GLSL_DIR>/<stem>.comp.glsl
#   <HPP_DIR>/<stem>.bindings.hpp
#   <SPV_DIR>/<stem>.spv
# -----------------------------------------------------------------------------
function(_flowvk_add_one_shader OUT_GLSL OUT_HPP OUT_SPV SHADER GLSL_DIR HPP_DIR SPV_DIR)
  _flowvk_ensure_shaderpp_tool()
  _flowvk_require_glslc()

  get_filename_component(_stem "${SHADER}" NAME_WE)      # multiply
  get_filename_component(_name "${SHADER}" NAME)         # multiply.comp

  set(_glsl "${GLSL_DIR}/${_name}.glsl")                 # multiply.comp.glsl
  set(_hpp  "${HPP_DIR}/${_stem}.bindings.hpp")          # multiply.bindings.hpp
  set(_spv  "${SPV_DIR}/${_stem}.spv")                   # multiply.spv

  add_custom_command(
    OUTPUT "${_glsl}" "${_hpp}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${GLSL_DIR}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${HPP_DIR}"
    COMMAND $<TARGET_FILE:FlowVk_ShaderPP>
            --in "${SHADER}"
            --out-glsl "${_glsl}"
            --out-hpp "${_hpp}"
    DEPENDS "${SHADER}" FlowVk_ShaderPP
    VERBATIM
  )

  add_custom_command(
    OUTPUT "${_spv}"
    COMMAND ${CMAKE_COMMAND} -E make_directory "${SPV_DIR}"
    COMMAND "${Vulkan_GLSLC_EXECUTABLE}"
            -c
            -fshader-stage=compute
            -o "${_spv}"
            "${_glsl}"
    DEPENDS "${_glsl}" "${_hpp}"
    VERBATIM
  )

  set(${OUT_GLSL} "${_glsl}" PARENT_SCOPE)
  set(${OUT_HPP}  "${_hpp}"  PARENT_SCOPE)
  set(${OUT_SPV}  "${_spv}"  PARENT_SCOPE)
endfunction()

# -----------------------------------------------------------------------------
# Internal: generate KernelBuffers.hpp aggregator into HPP_DIR
# - Includes all per-kernel bindings headers
# - Builds unordered_map<string_view, const Module*>
# - Provides get_module / try_get_module
# -----------------------------------------------------------------------------
function(_flowvk_generate_aggregator OUT_AGG_HPP HPP_DIR SHADERS)
  set(_agg "${HPP_DIR}/KernelBuffers.hpp")

  set(_content "#pragma once\n")
  string(APPEND _content "// Auto-generated by FlowVk CMake\n\n")
  string(APPEND _content "#include <string_view>\n")
  string(APPEND _content "#include <unordered_map>\n")
  string(APPEND _content "#include <stdexcept>\n")
  string(APPEND _content "#include <flowVk/ShaderMeta.hpp>\n\n")

  # Include per-kernel headers
  foreach(SHADER IN LISTS SHADERS)
    get_filename_component(_stem "${SHADER}" NAME_WE)
    string(APPEND _content "#include \"${_stem}.bindings.hpp\"\n")
  endforeach()

  string(APPEND _content "\nnamespace Flow::shader_meta::registry {\n\n")
  string(APPEND _content "using Flow::shader_meta::Module;\n\n")

  # registry map
  string(APPEND _content "inline const std::unordered_map<std::string_view, const Module*>& map() {\n")
  string(APPEND _content "  static const std::unordered_map<std::string_view, const Module*> reg = {\n")

  foreach(SHADER IN LISTS SHADERS)
    get_filename_component(_stem "${SHADER}" NAME_WE)
    # module symbol is: Flow::shader_meta::<stem>::module
    string(APPEND _content "    {\"${_stem}\", &Flow::shader_meta::${_stem}::module},\n")
  endforeach()

  string(APPEND _content "  };\n")
  string(APPEND _content "  return reg;\n")
  string(APPEND _content "}\n\n")

  # try_get_module
  string(APPEND _content "inline const Module* try_get_module(std::string_view name) {\n")
  string(APPEND _content "  const auto& reg = map();\n")
  string(APPEND _content "  auto it = reg.find(name);\n")
  string(APPEND _content "  if (it == reg.end()) return nullptr;\n")
  string(APPEND _content "  return it->second;\n")
  string(APPEND _content "}\n\n")

  # get_module
  string(APPEND _content "inline const Module& get_module(std::string_view name) {\n")
  string(APPEND _content "  if (const Module* m = try_get_module(name)) return *m;\n")
  string(APPEND _content "  throw std::runtime_error(\"FlowVk: Unknown kernel name\");\n")
  string(APPEND _content "}\n\n")

  string(APPEND _content "} // namespace Flow::shader_meta::registry\n")

  file(GENERATE
    OUTPUT "${_agg}"
    CONTENT "${_content}"
  )

  set(${OUT_AGG_HPP} "${_agg}" PARENT_SCOPE)
endfunction()

# -----------------------------------------------------------------------------
# Public API #3: emit only HPPs (and aggregator)
# NOTE: this assumes ShaderPP always produces both GLSL+HPP. If you later add
# true --out-hpp-only support, we can simplify this.
# -----------------------------------------------------------------------------
function(flowvk_emit_kernel_hpps)
  set(oneValueArgs TARGET)
  set(multiValueArgs SHADERS)
  cmake_parse_arguments(ARG "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

 	if(NOT ARG_TARGET)
  		message(FATAL_ERROR "flowvk_emit_kernel_hpps: TARGET is required")
	endif()
	if(NOT ARG_SHADERS)
		message(FATAL_ERROR "flowvk_emit_kernel_hpps: SHADERS is required")
	endif()

  _flowvk_validate_unique_stems("${ARG_SHADERS}")

  set(_hpp_dir  "${CMAKE_CURRENT_BINARY_DIR}/shaderInclude/$<CONFIG>")
  set(_glsl_dir "${CMAKE_CURRENT_BINARY_DIR}/shaders/$<CONFIG>") # dummy place

  _flowvk_ensure_shaderpp_tool()

  set(all_hpps "")
  foreach(SHADER IN LISTS ARG_SHADERS)
    get_filename_component(_stem "${SHADER}" NAME_WE)
    get_filename_component(_name "${SHADER}" NAME)

    set(_hpp  "${_hpp_dir}/${_stem}.bindings.hpp")
    set(_glsl "${_glsl_dir}/${_name}.glsl") # generated anyway by current ShaderPP

    add_custom_command(
      OUTPUT "${_hpp}" "${_glsl}"
      COMMAND ${CMAKE_COMMAND} -E make_directory "${_hpp_dir}"
      COMMAND ${CMAKE_COMMAND} -E make_directory "${_glsl_dir}"
      COMMAND $<TARGET_FILE:FlowVk_ShaderPP>
              --in "${SHADER}"
              --out-glsl "${_glsl}"
              --out-hpp "${_hpp}"
      DEPENDS "${SHADER}" FlowVk_ShaderPP
      VERBATIM
    )

    list(APPEND all_hpps "${_hpp}")
  endforeach()

  _flowvk_generate_aggregator(_agg "${_hpp_dir}" "${ARG_SHADERS}")

  target_include_directories("${ARG_TARGET}" PRIVATE "${_hpp_dir}")

  add_custom_target("${ARG_TARGET}__flowvk_hpps"
    DEPENDS ${all_hpps} "${_agg}"
  )
  add_dependencies("${ARG_TARGET}" "${ARG_TARGET}__flowvk_hpps")
endfunction()

# -----------------------------------------------------------------------------
# Public API #2: build full shader artifacts (GLSL+HPP+SPV) but do NOT link FlowVk
# -----------------------------------------------------------------------------
function(flowvk_build_kernels)
  set(oneValueArgs TARGET)
  set(multiValueArgs SHADERS)
  cmake_parse_arguments(ARG "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

	if(NOT ARG_TARGET) 
		message(FATAL_ERROR "flowvk_build_kernels: TARGET is required")
	endif()
	if(NOT ARG_SHADERS)
		message(FATAL_ERROR "flowvk_build_kernels: SHADERS is required")
	endif()

  _flowvk_validate_unique_stems("${ARG_SHADERS}")

  set(_glsl_dir "${CMAKE_CURRENT_BINARY_DIR}/shaders/$<CONFIG>")
  set(_spv_dir  "${CMAKE_CURRENT_BINARY_DIR}/shaders/$<CONFIG>")
  set(_hpp_dir  "${CMAKE_CURRENT_BINARY_DIR}/shaderInclude/$<CONFIG>")

  set(all_glsl "")
  set(all_hpps "")
  set(all_spv  "")

  foreach(SHADER IN LISTS ARG_SHADERS)
    _flowvk_add_one_shader(_glsl _hpp _spv "${SHADER}" "${_glsl_dir}" "${_hpp_dir}" "${_spv_dir}")
    list(APPEND all_glsl "${_glsl}")
    list(APPEND all_hpps "${_hpp}")
    list(APPEND all_spv  "${_spv}")
  endforeach()

  _flowvk_generate_aggregator(_agg "${_hpp_dir}" "${ARG_SHADERS}")

  add_custom_target("${ARG_TARGET}__flowvk_kernels"
    DEPENDS ${all_glsl} ${all_hpps} ${all_spv} "${_agg}"
  )
 
  add_dependencies("${ARG_TARGET}" "${ARG_TARGET}__flowvk_kernels")
  
  add_dependencies(FlowVk "${ARG_TARGET}__flowvk_kernels")

  target_include_directories("${ARG_TARGET}" PRIVATE "${_hpp_dir}")

  target_include_directories(FlowVk PRIVATE "${_hpp_dir}")

  target_compile_definitions(FlowVk PRIVATE FLOWVK_WITH_KERNEL_REGISTRY=1)

endfunction()

# -----------------------------------------------------------------------------
# Public API #1: main - build kernels AND link FlowVk
# -----------------------------------------------------------------------------
function(flowvk_add_kernels)
  set(oneValueArgs TARGET)
  set(multiValueArgs SHADERS)
  cmake_parse_arguments(ARG "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

	if(NOT ARG_TARGET)
  		message(FATAL_ERROR "flowvk_add_kernels: TARGET is required")
	endif()
	if(NOT ARG_SHADERS)
		message(FATAL_ERROR "flowvk_add_kernels: SHADERS is required")
	endif()

  flowvk_build_kernels(TARGET "${ARG_TARGET}" SHADERS ${ARG_SHADERS})
  target_link_libraries("${ARG_TARGET}" PRIVATE FlowVk::FlowVk)
endfunction()
